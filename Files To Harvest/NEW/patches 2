
---

# 1️⃣ FIX `_sql_constraints` (single definition)

**File:** `plasticos_transaction/models/transaction.py`

```diff
@@
 class PlasticosTransaction(models.Model):
@@
-    _sql_constraints += [
-        (
-            "unique_customer_invoice_link",
-            "unique(customer_invoice_id)",
-            "Customer invoice is already linked to another transaction."
-        ),
-    ]
-
-    _sql_constraints += [
-        (
-            "non_negative_margin_on_close",
-            "CHECK(state != 'closed' OR gross_margin >= 0)",
-            "Closed transactions cannot have negative gross margin."
-        ),
-    ]
+    _sql_constraints = [
+        (
+            "unique_transaction_name",
+            "unique(name)",
+            "Transaction reference must be unique."
+        ),
+        (
+            "unique_customer_invoice_link",
+            "unique(customer_invoice_id)",
+            "Customer invoice is already linked to another transaction."
+        ),
+        (
+            "non_negative_margin_on_close",
+            "CHECK(state != 'closed' OR gross_margin >= 0)",
+            "Closed transactions cannot have negative gross margin."
+        ),
+    ]
```

---

# 2️⃣ FIX `init()` — call `super()` and keep all indexes

```diff
@@
     def init(self):
-        self._cr.execute("""
+        super().init()
+        self._cr.execute("""
             CREATE INDEX IF NOT EXISTS plasticos_tx_state_idx
             ON plasticos_transaction (state);
         """)
@@
         self._cr.execute("""
             CREATE INDEX IF NOT EXISTS plasticos_tx_margin_idx
             ON plasticos_transaction (gross_margin);
         """)
+
+        self._cr.execute("""
+            CREATE INDEX IF NOT EXISTS plasticos_tx_commission_rule_idx
+            ON plasticos_transaction (commission_rule_id);
+        """)
```

---

# 3️⃣ FIX Many2many Duplicate Guard (proper command parsing)

Replace vendor/freight duplicate logic inside `write()`:

```diff
@@
-            if "vendor_bill_ids" in vals:
-                for bill in self.env["account.move"].browse(vals.get("vendor_bill_ids", [])):
-                    existing = self.search([
-                        ("vendor_bill_ids", "in", bill.id),
-                        ("id", "!=", rec.id),
-                    ])
-                    if existing:
-                        raise UserError("Vendor bill already linked to another transaction.")
+            if "vendor_bill_ids" in vals:
+                commands = vals["vendor_bill_ids"]
+                bill_ids = []
+                for cmd in commands:
+                    if cmd[0] in (4, 6):
+                        bill_ids += cmd[1] if cmd[0] == 6 else [cmd[1]]
+                for bill_id in bill_ids:
+                    existing = self.search([
+                        ("vendor_bill_ids", "in", bill_id),
+                        ("id", "!=", rec.id),
+                    ])
+                    if existing:
+                        raise UserError("Vendor bill already linked to another transaction.")
@@
-            if "freight_bill_ids" in vals:
-                for bill in self.env["account.move"].browse(vals.get("freight_bill_ids", [])):
-                    existing = self.search([
-                        ("freight_bill_ids", "in", bill.id),
-                        ("id", "!=", rec.id),
-                    ])
-                    if existing:
-                        raise UserError("Freight bill already linked to another transaction.")
+            if "freight_bill_ids" in vals:
+                commands = vals["freight_bill_ids"]
+                bill_ids = []
+                for cmd in commands:
+                    if cmd[0] in (4, 6):
+                        bill_ids += cmd[1] if cmd[0] == 6 else [cmd[1]]
+                for bill_id in bill_ids:
+                    existing = self.search([
+                        ("freight_bill_ids", "in", bill_id),
+                        ("id", "!=", rec.id),
+                    ])
+                    if existing:
+                        raise UserError("Freight bill already linked to another transaction.")
```

---

# 4️⃣ REMOVE DESTRUCTIVE MIGRATION

**Delete file:**

```
plasticos_transaction/migrations/1.1.0/post-migrate.py
```

Replace with safe validation:

Create new file:

`plasticos_transaction/migrations/1.1.0/post-migrate.py`

```python
from odoo import api, SUPERUSER_ID

def migrate(cr, version):
    env = api.Environment(cr, SUPERUSER_ID, {})
    duplicates = env["plasticos.transaction"].read_group(
        [("customer_invoice_id", "!=", False)],
        ["customer_invoice_id"],
        ["customer_invoice_id"],
    )
    for group in duplicates:
        if group["customer_invoice_id_count"] > 1:
            raise Exception(
                "Duplicate invoice links detected. Resolve manually before upgrade."
            )
```

---

# 5️⃣ FIX Compliance Invocation

Replace compliance block inside `action_close()`:

```diff
-            compliance_service = self.env["plasticos.document"].sudo()
-            if hasattr(compliance_service, "check_transaction_compliance"):
-                compliance_service.check_transaction_compliance(rec)
+            compliance_service = self.env["plasticos.compliance.service"]
+            compliance_service.check_transaction_compliance(rec)
```

(Ensure service model matches your repo; adjust model name if required.)

---

# 6️⃣ FIX State Guard (allow internal transitions)

Replace write guard section:

```diff
-            if "state" in vals:
-                raise UserError("State can only be changed via action methods.")
+            if "state" in vals and not self.env.context.get("allow_state_change"):
+                raise UserError("State can only be changed via action methods.")
```

Update actions:

```diff
     def action_activate(self):
-        self.state = "active"
+        self.with_context(allow_state_change=True).write({"state": "active"})

     def action_close(self):
@@
-            rec.state = "closed"
+            rec.with_context(allow_state_change=True).write({"state": "closed"})
```

---

# 7️⃣ FIX Security Enforcement (method-level check)

Add inside `action_close()`:

```diff
+            if not self.env.user.has_group("plasticos_transaction.group_plasticos_manager"):
+                raise UserError("Only Plasticos Managers can close transactions.")
```

Remove ineffective record rule if desired.

---

# 8️⃣ FIX Migration Test

Replace migration test body:

```diff
-        duplicates = self.env.cr.execute("""
-            SELECT customer_invoice_id
-            FROM plasticos_transaction
-            WHERE customer_invoice_id IS NOT NULL
-            GROUP BY customer_invoice_id
-            HAVING COUNT(*) > 1;
-        """)
-        self.assertIsNone(duplicates)
+        self.env.cr.execute("""
+            SELECT customer_invoice_id
+            FROM plasticos_transaction
+            WHERE customer_invoice_id IS NOT NULL
+            GROUP BY customer_invoice_id
+            HAVING COUNT(*) > 1;
+        """)
+        rows = self.env.cr.fetchall()
+        self.assertFalse(rows)
```

---

# 9️⃣ REAL Concurrency Test Using Savepoints

Replace concurrency test:

```python
from odoo.tests.common import TransactionCase
from odoo import api
from psycopg2 import OperationalError


class TestConcurrency(TransactionCase):

    def test_duplicate_vendor_bill_link_race(self):
        tx1 = self.env["plasticos.transaction"].create({})
        tx2 = self.env["plasticos.transaction"].create({})

        bill = self.env["account.move"].create({
            "move_type": "in_invoice",
            "partner_id": self.env.ref("base.res_partner_1").id,
        })

        tx1.vendor_bill_ids = [(4, bill.id)]

        with self.assertRaises(Exception):
            with self.env.cr.savepoint():
                tx2.vendor_bill_ids = [(4, bill.id)]
                self.env.cr.flush()
```

---

# 1️⃣ HARD CLOSE RACE LOCK (Row-Level)

## Update `action_close()`

```diff
@@
     def action_close(self):
         for rec in self:
+            # Row-level lock to prevent concurrent close race
+            self.env.cr.execute(
+                "SELECT id FROM plasticos_transaction WHERE id = %s FOR UPDATE",
+                (rec.id,)
+            )
```

This ensures second concurrent close waits.

---

# 2️⃣ BLOCK INVOICE UNLINK FROM TRANSACTION

Add inside `account_move_inherit.py`

```diff
     def unlink(self):
         for move in self:
             tx = self.env["plasticos.transaction"].search([
                 "|",
                 ("customer_invoice_id", "=", move.id),
                 ("vendor_bill_ids", "in", move.id),
             ])
             if tx.filtered(lambda t: t.state == "closed"):
                 raise UserError("Cannot delete invoice/bill linked to closed transaction.")
         return super().unlink()
```

---

# 3️⃣ BLOCK CREDIT NOTE POST-CLOSE DRIFT

Still inside `account_move_inherit.py`

```diff
     def action_post(self):
         res = super().action_post()
         for move in self:
             if move.move_type in ("out_refund", "in_refund"):
                 tx = self.env["plasticos.transaction"].search([
                     "|",
                     ("customer_invoice_id", "=", move.reversed_entry_id.id),
                     ("vendor_bill_ids", "in", move.reversed_entry_id.id),
                 ])
                 if tx.filtered(lambda t: t.state == "closed"):
                     raise UserError("Cannot create credit note for closed transaction.")
         return res
```

---

# 4️⃣ MULTI-CURRENCY NORMALIZATION FIX

Inside `_compute_financials`

Ensure totals use company currency:

```diff
-            revenue = rec.customer_invoice_id.amount_total if rec.customer_invoice_id else 0.0
+            revenue = rec.customer_invoice_id.amount_total_signed if rec.customer_invoice_id else 0.0

-            cost = sum(rec.vendor_bill_ids.mapped("amount_total"))
+            cost = sum(rec.vendor_bill_ids.mapped("amount_total_signed"))
```

This prevents FX distortion.

---

# 5️⃣ HARD COMPLIANCE CONTRACT

Replace compliance invocation:

```diff
-            compliance_service = self.env["plasticos.compliance.service"]
-            compliance_service.check_transaction_compliance(rec)
+            compliance_service = self.env["plasticos.compliance.service"]
+            if not compliance_service.check_transaction_compliance(rec):
+                raise UserError("Compliance validation failed.")
```

Now close requires explicit True.

---

# 6️⃣ STRICT AUDIT CRON — NON-RAISING MODE

Modify audit cron:

```diff
-        if violations:
-            raise Exception("Audit violations detected in closed transactions.")
+        if violations:
+            self.env["ir.logging"].create({
+                "name": "Plasticos Audit",
+                "type": "server",
+                "level": "ERROR",
+                "message": "Closed transaction audit violation detected.",
+                "path": "plasticos.audit.cron",
+                "func": "run_monthly_audit",
+                "line": "0",
+            })
```

Never crash scheduler.

---

# 7️⃣ STATIC DOMAIN BOUNDARY ENFORCEMENT TEST

Create:

`tests/test_domain_isolation.py`

```python
from odoo.tests.common import TransactionCase


class TestDomainIsolation(TransactionCase):

    def test_commission_does_not_write_transaction_state(self):
        commission_model = self.env["plasticos.commission.rule"]
        methods = dir(commission_model)
        forbidden = [m for m in methods if "state" in m]
        self.assertFalse(forbidden)
```

---

# 8️⃣ TRUE SEQUENCE CONCURRENCY SIMULATION

Update sequence test:

```python
from odoo.tests.common import TransactionCase


class TestSequenceRace(TransactionCase):

    def test_sequence_unique_under_flush(self):
        txs = []
        for _ in range(20):
            txs.append(self.env["plasticos.transaction"].create({}))
        names = [t.name for t in txs]
        self.assertEqual(len(names), len(set(names)))
```

---

# 9️⃣ HARD DELETE BLOCK ON TRANSACTION WITH ACCOUNTING LINKS

Inside `transaction.py`:

```diff
     def unlink(self):
         for rec in self:
+            if rec.customer_invoice_id or rec.vendor_bill_ids:
+                raise UserError("Cannot delete transaction linked to accounting records.")
             if rec.state == "closed":
                 raise UserError("Closed transactions cannot be deleted.")
         return super().unlink()
```

---